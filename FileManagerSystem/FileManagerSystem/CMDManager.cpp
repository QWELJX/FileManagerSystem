#include <algorithm>
#include <sstream>
#include <cctype> 
#include "CMDManager.h"
#include "FileManager.h" 
CMDManager::CMDManager() : m_Fm(nullptr), DIR("") {


    commandMap["register"] = [this](const std::vector<std::string>& tokens) -> void {
        this->handleRgt(tokens);
        };

    commandMap["clear"] = [this](const std::vector<std::string>& tokens) -> void {
        this->handleCls(tokens);
        };

    commandMap["cls"] = commandMap["clear"];

    commandMap["back"] = [this](const std::vector<std::string>& tokens) -> void {
        this->handleBack(tokens);
        };

    commandMap["b"] = commandMap["back"];

    commandMap["add"] = [this](const std::vector<std::string>& tokens) -> void {
        this->handleAdd(tokens);
        };

    commandMap["delete"] = [this](const std::vector<std::string>& tokens) -> void {
        this->handleDelete(tokens);
        };

    commandMap["del"] = commandMap["delete"];

    commandMap["goto"] = [this](const std::vector<std::string>& tokens) -> void {
        this->handleGoto(tokens);
        };

    commandMap["cd"] = commandMap["goto"];

    commandMap["list"] = [this](const std::vector<std::string>& tokens) -> void {
        this->handleList(tokens);
        };

    commandMap["ls"] = commandMap["list"];

    commandMap["help"] = [this](const std::vector<std::string>& tokens) -> void {
        this->handleHelp(tokens);
        };
};

void CMDManager::Run() {
    while (true) {
        this->Show();
        std::string content;
        std::getline(std::cin, content);
        this->appendContent(content + "\n");

        std::stringstream ss(content);
        std::vector<std::string> tokens;
        std::string token;

        while (ss >> token) {
            tokens.push_back(token);
        }

        if (tokens.empty()) {
            continue;
        }
        else if (tokens[0] == "quit") {
            break;
        }

        this->RunCMD(tokens);
    }
}

void CMDManager::RunCMD(const std::vector<std::string>& tokens) {
    std::string command = toLower(tokens[0]);
    auto it = commandMap.find(command);
    if (it != commandMap.end()) {
        it->second(tokens);
    }
    else {
        this->appendContent("无法识别命令: " + tokens[0] + "\n" + "输入 'help' 查看可用命令\n");
    }
}

void CMDManager::Show() {
    system("cls");
    if (m_Fm) {
        this->m_Fm->Show();
        this->duiQi(4);
    }
    else {
        this->duiQi(20);
    }

    std::cout << std::endl << "--------------------------------------------------" << std::endl;
    this->appendContent(DIR + "> ");
    this->showContent();
}

void CMDManager::handleRgt(const std::vector<std::string>& tokens) {
    if (tokens.size() != 2) {
        this->appendContent("错误: register 命令多余或缺少参数\n");
        return;
    }
    std::string name = tokens[1];
    this->setDirectory(name);
    FileManager* newFm = new FileManager(name);
    this->setFileManager(newFm);

}

void CMDManager::handleCls(const std::vector<std::string>& tokens) {
    if (tokens.size() != 1) {
        this->appendContent("错误: cls 命令有多余参数\n");
        return;  // 添加return
    }
    this->clearContent();//asd
}

void CMDManager::handleBack(const std::vector<std::string>& tokens) {
    if (tokens.size() != 1) {
        this->appendContent("错误: back 命令不需要参数\n");  // 修正错误信息
        return;  // 添加return
    }

    //// 添加实际的后退逻辑
    //if (m_Fm && m_Fm->getNodeManager()) {
    //    m_Fm->getNodeManager()->GoToParent();
    //    m_Fm->getNodeManager()->Refresh();
    //}
}

void CMDManager::handleAdd(const std::vector<std::string>& tokens) {

    if (!m_Fm) {
        this->appendContent("错误: CMDManager 未初始化\n");
        return;
    }
    size_t t = tokens.size();
    if (t < 2) {
        this->appendContent("错误: 缺少参数\n");
        return;
    }
    std::string name = tokens[1];
    if (t == 2) {
        this->m_Fm->getNM()->handleAdd(name);
        return;
    }
    else if (t == 3) {
        std::string type = tokens[2];
        this->m_Fm->getNM()->handleAdd(name, stringToFileType(type));
        return;
    }
    else {
        this->appendContent("错误: 多余参数\n");
        return;
    }


}

// 添加其他命令处理函数的实现
void CMDManager::handleDelete(const std::vector<std::string>& tokens) {
    this->appendContent("删除功能待实现\n");
}

void CMDManager::handleGoto(const std::vector<std::string>& tokens) {
    this->appendContent("跳转功能待实现\n");
}

void CMDManager::handleList(const std::vector<std::string>& tokens) {
    /*if (m_Fm && m_Fm->getNodeManager()) {
        m_Fm->getNodeManager()->Refresh();
    }*/
}

void CMDManager::handleHelp(const std::vector<std::string>& tokens) {
    this->appendContent("可用命令:\n");
    this->appendContent("  register <name>              - 注册文件管理器\n");
    this->appendContent("  cls/clear                    - 清屏\n");
    this->appendContent("  back/b                       - 返回上级目录\n");
    this->appendContent("  add <name> <type>            - 添加文件/目录\n");
    this->appendContent("  del/delete <name>/<index>    - 删除\n");
    this->appendContent("  goto/cd <index>              - 进入目录\n");
    this->appendContent("  list/ls                      - 刷新显示\n");
    this->appendContent("  help                         - 显示帮助\n");
    this->appendContent("  quit                         - 退出程序\n");
}

// 工具函数实现
bool CMDManager::isPureNumber(const std::string& str) {
    return !str.empty() &&
        std::all_of(str.begin(), str.end(),
            [](char c) { return std::isdigit(static_cast<unsigned char>(c)); });
}

std::string CMDManager::toLower(const std::string& str) {
    std::string result = str;
    std::transform(result.begin(), result.end(), result.begin(),
        [](unsigned char c) { return std::tolower(c); });
    return result;
}
void CMDManager::duiQi(size_t t) {
    for (int i = 0; i < t; ++i)
        std::cout << std::endl;
}